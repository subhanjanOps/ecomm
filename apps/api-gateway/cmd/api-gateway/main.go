package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"os"

	_ "ecomm/api-gateway/docs"

	_ "github.com/lib/pq"
	httpSwagger "github.com/swaggo/http-swagger"

	"ecomm/api-gateway/internal/admin"
	hc "ecomm/api-gateway/internal/health"
	mg "ecomm/api-gateway/internal/migrate"
	"ecomm/api-gateway/internal/proxy"
	"ecomm/api-gateway/internal/registry"
	"ecomm/api-gateway/internal/util"
)

// @title Ecomm API Gateway
// @version 1.0
// @description Gateway admin and proxy API
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization

func main() {
	port := getenv("PORT", "8080")

	// DB setup (Postgres) - optional for dev
	var db *sql.DB
	dsn := getenv("DATABASE_URL", "")
	var repo registry.Repository = registry.NewMemoryRepository()
	if dsn != "" {
		var err error
		db, err = sql.Open("postgres", dsn)
		if err != nil {
			log.Fatalf("db open: %v", err)
		}
		schema := getenv("GATEWAY_DB_SCHEMA", "gateway")
		repo = registry.NewPostgresRepository(db, schema)
		if err := repo.Init(); err != nil {
			log.Fatalf("db init: %v", err)
		}
	} else {
		log.Printf("warning: DATABASE_URL not set; using in-memory registry (non-persistent)")
	}
	if dsn == "" {
		log.Fatal("DATABASE_URL is required for api-gateway")
	}
	var err error
	db, err = sql.Open("postgres", dsn)
	if err != nil {
		log.Fatalf("db open: %v", err)
	}
	schema := getenv("GATEWAY_DB_SCHEMA", "gateway")
	// Run migrations (schema + tables)
	if err := mg.Run(db, schema); err != nil {
		log.Fatalf("migrations: %v", err)
	}
	repo = registry.NewPostgresRepository(db, schema)

	// Routing registry
	reg := registry.New()
	if err := registry.LoadEnabled(repo, reg); err != nil {
		log.Printf("warn: load registry failed: %v", err)
	}

	mux := http.NewServeMux()
	// Basic health endpoints
	mux.HandleFunc("/healthz", healthzHandler)
	mux.HandleFunc("/readyz", readyzHandler)

	// Dynamic reverse proxy for services (public)
	mux.HandleFunc("/api/", proxy.Dynamic(reg))

	// Admin API (protected by JWT)
	adm := admin.NewHandler(repo, reg)
	jwtSecret := getenv("JWT_SECRET", "")
	mux.HandleFunc("/admin/services", util.CORS(util.JWTAuth(jwtSecret)(adm.Services)))
	mux.HandleFunc("/admin/services/", util.CORS(util.JWTAuth(jwtSecret)(adm.ServiceByID)))

	// Swagger UI (generated by swaggo). Access: /swagger/index.html
	mux.Handle("/swagger/", httpSwagger.WrapHandler)

	srv := &http.Server{Addr: ":" + port, Handler: mux}
	// Start background health checker
	interval := getenv("HEALTH_CHECK_SECONDS", "30")
	hc.Start(repo, interval)

	log.Printf("api-gateway listening on :%s", port)
	log.Fatal(srv.ListenAndServe())
}

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

// healthzHandler godoc
// @Summary Liveness probe
// @Tags system
// @Produce json
// @Success 200 {object} map[string]string
// @Router /healthz [get]
func healthzHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{"status": "ok"})
}

// readyzHandler godoc
// @Summary Readiness probe
// @Tags system
// @Produce json
// @Success 200 {object} map[string]string
// @Router /readyz [get]
func readyzHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{"status": "ready"})
}
