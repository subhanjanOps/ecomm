package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"os"

	_ "ecomm/api-gateway/docs"

	_ "github.com/lib/pq"
	httpSwagger "github.com/swaggo/http-swagger"

	"ecomm/api-gateway/internal/admin"
	hc "ecomm/api-gateway/internal/health"
	mg "ecomm/api-gateway/internal/migrate"
	"ecomm/api-gateway/internal/proxy"
	"ecomm/api-gateway/internal/registry"
	"ecomm/api-gateway/internal/util"
)

// @title Ecomm API Gateway
// @version 1.0
// @description The Ecomm API Gateway provides a unified entrypoint that proxies requests to onboarded backend services.
// The gateway supports service onboarding and lifecycle management via the Admin API, dynamic routing to
// registered backends based on `public_prefix`, background health checks that update service status,
// and an embedded Swagger UI for human-readable API discovery. Admin endpoints require JWT Bearer authentication.
// Services are persisted in Postgres (set `DATABASE_URL`) and stored under the schema configured by
// `GATEWAY_DB_SCHEMA`. On startup the gateway runs embedded migrations to create the necessary schema and tables.
//
// Environment variables of interest:
// - `DATABASE_URL` (required): Postgres connection string used as the source-of-truth for services.
// - `GATEWAY_DB_SCHEMA` (optional, default "gateway"): Postgres schema where gateway tables are stored.
// - `JWT_SECRET` (optional for local dev): HMAC secret used to validate Admin JWT Bearer tokens.
// - `HEALTH_CHECK_SECONDS` (optional): Interval in seconds for background health probes.
//
// @termsOfService https://example.com/terms/
// @contact.name Ecomm Platform Team
// @contact.url https://example.com/support
// @contact.email ops@example.com
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @host localhost:8080
// @BasePath /
// @schemes http https
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @tag.name admin
// @tag.description Admin operations for onboarding and managing backend services (create, update, delete, refresh)
// @tag.name proxy
// @tag.description Proxy endpoints that forward incoming traffic under `/api/` to onboarded services using
// longest-prefix matching on `public_prefix`.
// @tag.name system
// @tag.description System endpoints for health, readiness, and operational status

func main() {
	port := getenv("PORT", "8080")

	// DB setup (Postgres) - optional for dev
	var db *sql.DB
	dsn := getenv("DATABASE_URL", "postgres://ecomm:ecommpass@localhost:5432/ecomm?sslmode=disable")
	var repo registry.Repository = registry.NewMemoryRepository()
	if dsn != "" {
		var err error
		db, err = sql.Open("postgres", dsn)
		if err != nil {
			log.Fatalf("db open: %v", err)
		}
		schema := getenv("GATEWAY_DB_SCHEMA", "gateway")
		repo = registry.NewPostgresRepository(db, schema)
		if err := repo.Init(); err != nil {
			log.Fatalf("db init: %v", err)
		}
	} else {
		log.Printf("warning: DATABASE_URL not set; using in-memory registry (non-persistent)")
	}
	if dsn == "" {
		log.Fatal("DATABASE_URL is required for api-gateway")
	}
	var err error
	db, err = sql.Open("postgres", dsn)
	if err != nil {
		log.Fatalf("db open: %v", err)
	}
	schema := getenv("GATEWAY_DB_SCHEMA", "gateway")
	// Run migrations (schema + tables)
	if err := mg.Run(db, schema); err != nil {
		log.Fatalf("migrations: %v", err)
	}
	repo = registry.NewPostgresRepository(db, schema)

	// Routing registry
	reg := registry.New()
	if err := registry.LoadEnabled(repo, reg); err != nil {
		log.Printf("warn: load registry failed: %v", err)
	}

	mux := http.NewServeMux()
	// Basic health endpoints
	mux.HandleFunc("/healthz", healthzHandler)
	mux.HandleFunc("/readyz", readyzHandler)

	// Dynamic reverse proxy for services (public)
	mux.HandleFunc("/api/", proxy.Dynamic(reg))

	// Admin API (protected by JWT)
	adm := admin.NewHandler(repo, reg)
	jwtSecret := getenv("JWT_SECRET", "")
	mux.HandleFunc("/admin/services", util.CORS(util.JWTAuth(jwtSecret)(adm.Services)))
	mux.HandleFunc("/admin/services/", util.CORS(util.JWTAuth(jwtSecret)(adm.ServiceByID)))

	// Swagger UI (generated by swaggo). Access: /swagger/index.html
	mux.Handle("/swagger/", httpSwagger.WrapHandler)

	srv := &http.Server{Addr: ":" + port, Handler: mux}
	// Start background health checker
	interval := getenv("HEALTH_CHECK_SECONDS", "30")
	hc.Start(repo, interval)

	log.Printf("api-gateway listening on :%s", port)
	log.Fatal(srv.ListenAndServe())
}

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

// healthzHandler godoc
// @Summary Liveness probe
// @Tags system
// @Produce json
// @Success 200 {object} map[string]string
// @Router /healthz [get]
func healthzHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{"status": "ok"})
}

// readyzHandler godoc
// @Summary Readiness probe
// @Tags system
// @Produce json
// @Success 200 {object} map[string]string
// @Router /readyz [get]
func readyzHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{"status": "ready"})
}
